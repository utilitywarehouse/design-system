import { Meta, Canvas, ArgTypes, Description } from '@storybook/blocks';
import * as Stories from './IconButton.stories';

<Meta of={Stories} />

# IconButton

<Description />

<Canvas of={Stories.SimpleExample} />

## Contents

- [Icons](#icons)
- [Accessibility](#accessibility)
- [Variant](#variant)
  - [Solid](#solid)
  - [Outline](#outline)
  - [Ghost](#ghost)
- [ColorScheme](#colorscheme)
  - [Cyan](#cyan)
  - [Green](#green)
  - [Red](#red)
  - [Gold](#gold)
  - [Grey](#grey)
- [Size](#size)
  - [Responsive icon sizes](#responsive-icon-sizes)
- [Semantic HTML](#semantic-html)
- [API Reference](#api-reference)

## Icons

This button is intended to be used with the UW icons packages. If you do use
another icon, please add the `data-icon` attribute to your icon so that it
renders the appropriate styles.

```tsx
<IconButton>
  <ChevronRightMediumIcon />
</IconButton>

[...]

<IconButton>
  <MyFontIcon aria-hidden="true" data-icon />
</IconButton>
```

## Accessibility

Icons from the UW icons packages have `aria-hidden="true"` set by default. If
you are using an icon from outside these packages, and for purely decorative
reasons, please ensure it has this attribute set so that the icon is hidden
from screen readers.

## Variant

The variant prop controls the visual appearance of the button.

```tsx
<Flex gap={2} align="center">
  <IconButton variant="solid">
    <ChevronRightMediumIcon />
  </IconButton>
  <IconButton variant="outline">
    <ChevronRightMediumIcon />
  </IconButton>
  <IconButton variant="ghost">
    <ChevronRightMediumIcon />
  </IconButton>
</Flex>
```

### Solid

The solid button can be combined with the `cyan`, `red` & `green` color schemes.

<Canvas of={Stories.SolidVariant} />

### Outline

The outline button can be combined with all color schemes.

<Canvas of={Stories.OutlineVariant} />

### Ghost

The ghost button can be combined with all color schemes.

<Canvas of={Stories.GhostVariant} />

## ColorScheme

The colorScheme prop will change the button colours. Be aware there are some
combinations of colorScheme & variant that do not work together (ie. `solid` &
`grey`), and if used will render a button with no colours at all.

```tsx
<IconButton colorScheme="red">
```

### Cyan

Cyan serves as the default color scheme for primary actions.

### Green

The green button color scheme is ideal for indicating positive or affirmative
actions. This color can be used when you want to draw attention to actions that
confirm or approve something.

### Red

The red color scheme is most suitable for destructive actions that could result
in data loss, are irreversible, or will have significant and negative
consequences for the user. It serves as a visual warning to approach such
actions with caution due to their potential substantial impact.

### Gold

Gold buttons are commonly linked to actions that demand user attention or
decision-making. They serve as a signal to users that they should proceed with
care. However, it's important to note that gold buttons don't convey the same
level of urgency or potential consequences as red buttons do.

### Grey

The grey color scheme is best suited for situations where you want the button
to have very low prominence. It's especially useful in designs that are
color-heavy, as it allows the button to blend in with the overall color scheme,
making it less visually prominent.

## Size

The size prop controls the size of the button. This is a responsive prop and
can be used to display different sizes at different breakpoints.

<Canvas of={Stories.Sizes} />

```tsx
<Button
  size={{
    mobile: 'small',
    desktop: 'large',
  }}
/>
```

### Responsive icon sizes

If you need to render different sized icons in conjunction with the responsive
size prop, there are a couple of ways you can do this.

1. Using JS, with the `useMediaQuery` hook.

```tsx
import { IconButton, useMediaQuery } from '@utilitywarehouse/web-ui';
import { ChevronRight01MediumIcon, ChevronRight01SmallIcon } from '@utilitywarehouse/react-icons';

const MyComponent = () => {
  const isDesktop = useMediaQuery(theme => theme.breakpoints.up('desktop'));

  return (
    <IconButton size={{ mobile: 'small', desktop: 'large' }}>
      {isDesktop ? <ChevronRight01MediumIcon /> : <ChevronRight01SmallIcon />}
    </IconButton>
  );
};
```

2. Using CSS, with `Box` and style props. This can also be achieved with the `sx` prop.

```tsx
import { Button, Box } from '@utilitywarehouse/web-ui';
import { ChevronRight01MediumIcon, ChevronRight01SmallIcon } from '@utilitywarehouse/react-icons';

const MyComponent = () => {
  const isDesktop = useMediaQuery(theme => theme.breakpoints.up('desktop'));

  return (
    <Button size={{ mobile: 'small', desktop: 'large' }}>
      Next page
      <Box component={ChevronRight01MediumIcon} display={{ mobile: 'none', desktop: 'block' }} />
      <Box component={ChevronRight01SmallIcon} display={{ desktop: 'none' }} />
    </Button>
  );
};
```

## Semantic HTML

A semantic HTML button is rendered by default, however you can change the underlying HTML element by using the `asChild` prop.
When `asChild` is set to true, Radix will not render a default DOM element,
instead cloning the child and passing it the props and behaviour required to
make it functional.
Read more about this idea in the [Radix UI composition docs](https://www.radix-ui.com/primitives/docs/guides/composition).

<Canvas of={Stories.AsLink} />

```tsx
<IconButton asChild>
  <a href="https://uw.co.uk/services">
    <OpenMediumIcon />
  </a>
</IconButton>
```

## API Reference

<ArgTypes of={Stories} />
