import { Meta, Description, Canvas, ArgTypes } from '@storybook/blocks';
import * as RadioGroupStories from './RadioGroup.stories';
import * as RadioItemStories from './RadioItem.stories';
import * as RadioTileStories from './RadioTile.stories';
import { Stack } from '../Stack';
import { Box } from '../Box';
import { Text } from '../Text';
import { Divider } from '@mui/material';

<Meta of={RadioGroupStories} />

# RadioGroup

- [Accessibility](#accessibility)
  - [Keyboard interactions](#keyboard-interactions)
- [Helper text](#helper-text)
- [Error message](#error-message)
- [Controlled](#controlled)
- [RadioGroup props](#radiogroup-props)
- [RadioItem](#radioitem)
  - [RadioItem accessibility](#radioitem-accessibility)
  - [RadioItem props](#radioitem-props)

<Description of={RadioGroupStories} />

<Canvas
  of={RadioGroupStories.Workshop}
  sourceState="shown"
  source={{
    code: `
<RadioGroup defaultValue={1} label="Label" helperText="RadioGroup Helper text">
  <RadioItem value="1" helperText="One helper text">
    One
  </RadioItem>
  <RadioItem value="2" helperText="Two helper text">
    Two
  </RadioItem>
  <RadioItem value="3" helperText="Three helper text">
    Three
  </RadioItem>
</RadioGroup>
`,
  }}
/>

## Accessibility

Follows the [WAI-ARIA Radio Group Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/radio/) for radio groups not contained in a toolbar.

> **NOTE**
> The initial focus behaviour when using `Shift+Tab` to move focus into the
> radio group, if none of the radio buttons are selected, reflects the native
> browser behaviour, rather than that described in the WAI-ARIA pattern, as it
> focuses the last radio button in the group, rather than the first.

The necessary aria props, such as `aria-labelledby`, `aria-describedby` and
`aria-errormessage` are handled internally, however you can pass these and
other aria props, such as `aria-label`, to the `RadioGroup` and `RadioItem`
components yourself if you need to.

### Keyboard interactions

<Stack spacing={1} divider={<Divider />}>
  <Box display="flex" alignItems="baseline">
    <Box width={300}>
      <Text component="span" variant="legalNote">
        {'Key'}
      </Text>
    </Box>
    <Text component="span" variant="legalNote">
      {'Description'}
    </Text>
  </Box>
  {[
    {
      key: 'Tab',
      description:
        'Moves focus to either the checked radio item or the first radio item in the group.',
    },
    {
      key: 'Shift+Tab',
      description:
        'Moves focus to either the checked radio item or the last radio item in the group.',
    },
    {
      key: 'Space',
      description: 'When focus is on an unchecked radio item, checks it.',
    },
    {
      key: 'Arrow Down / Arrow Right',
      description: 'Moves focus and checks the next radio item in the group.',
    },
    {
      key: 'Arrow Up / Arrow Left',
      description: 'Moves focus and checks the previous radio item in the group.',
    },
  ].map(kbi => (
    <Box display="flex" alignItems="baseline">
      <Box width={300}>
        <kbd>{kbi.key}</kbd>
      </Box>
      <Text component="span" variant="body">
        {kbi.description}
      </Text>
    </Box>
  ))}
</Stack>

## Helper text

The Radio group can display a secondary message as a helper text. This can be
either above or below the group's radio items. While the radio items can also
display a helper text, these will not be displayed if the radio group has a
helper text.

<Canvas of={RadioGroupStories.WithRadioItemHelperText} />

## Error message

In general, radio buttons should have a value selected by default. If this is
not the case, you can display an error if no value is selected when the form is
submitted.

<Canvas of={RadioGroupStories.ShowingError} sourceState="none" />

## Width

The width of the `RadioGroup` should be set by the parent layout, however it is
possible to independently set the width of the children using `contentWidth`
prop. This property is most useful when using the `RadioGroup` with the
`RadioTile` component.

By default it will set the width of the children to fit their content, however
you can set it to a specific width, or to `100%` to take up the full width of
the `RadioGroup`.

This is a responsive property, so you are able to set different widths for
different breakpoints.

## Controlled

A controlled value can be provided using the value prop, which accepts a value
corresponding with the value prop of each `RadioItem`. The onChange event is fired
when the user selects a `RadioItem`.

<Canvas of={RadioGroupStories.Controlled} sourceState="shown"
source={{
code: `
const [selected, setSelected] = useState('')

[...]

<RadioGroup
  value={selected}
  onChange={setSelected}
  helperText={'The selected value is: ' + selected}
>
  <RadioItem value="1">One</RadioItem>
  <RadioItem value="2">Two</RadioItem>
  <RadioItem value="3">Three</RadioItem>
</RadioGroup>
`, }} />

## RadioGroup props

<ArgTypes of={RadioGroupStories} />

## RadioItem

<Description of={RadioItemStories} />

### RadioItem accessibility

The `RadioItem` is, by default, appropriately labelled using it's children, if
you do not provide children, you must specify an `aria-label` for
accessibility.

### RadioItem props

<ArgTypes of={RadioItemStories} />

## RadioTile

<Description of={RadioTileStories} />

### RadioTile accessibility

The `RadioTile` is, by default, appropriately labelled using it's children, if
you do not provide children, you must specify an `aria-label` for
accessibility.

### RadioTile props

<ArgTypes of={RadioItemStories} />
